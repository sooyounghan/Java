-----
### 자원 정리1
-----
1. CallException (/tcp/autoclosable)
```java
package network.tcp.autoclosable;

public class CallException extends Exception {
    public CallException(String message) {
        super(message);
    }
}
```
2. CloseException (/tcp/autoclosable)
```java
package network.tcp.autoclosable;

public class CloseException extends Exception {
    public CloseException(String message) {
        super(message);
    }
}
```

3. ResourceV1 (/tcp/autoclosable)
```java
package network.tcp.autoclosable;

public class ResourceV1 {
    private String name;

    public ResourceV1(String name) {
        this.name = name;
    }

    public void call() { // 호출
        System.out.println(name + " call");
    }

    public void callEx() throws CallException { // CallException
        System.out.println(name + " call Ex");
        throw new CallException(name + " ex");
    }

    public void close() { // 자원 정리
        System.out.println(name + " close");
    }

    public void closeEx() throws CloseException { // CloseException
        System.out.println(name + " closeEx");
        throw new CloseException(name + " ex");
    }
}
```

  - call() : 정상 로직 호출
  - callEx() : 비정상 로직 호출 (CallException을 던짐)
  - close() : 정상 종료
  - closeEx() : 비정상 종료 (CloseException을 던짐)

4. ResourceCloseMainV1
```java
package network.tcp.autoclosable;

public class ResourceCloseMainV1 {
    public static void main(String[] args) {
        try {
            logic();
        } catch (CallException e) {
            System.out.println("CallException 예외 처리");
            throw new RuntimeException(e);
        } catch (CloseException e) {
            System.out.println("CloseException 예외 처리");
            throw new RuntimeException(e);
        }
    }

    private static void logic() throws CallException, CloseException {
        ResourceV1 resource1 = new ResourceV1("resource1");
        ResourceV1 resource2 = new ResourceV1("resource2");

        resource1.call();
        resource2.callEx(); // CallException

        System.out.println("자원 정리"); // 호출 되지 않음
        resource2.closeEx(); // 자원 정리 단계에서 CloseException
        resource1.closeEx();
    }
}
```
  - 서로 관련된 자원은 나중에 생성한 자원을 먼저 정리해야 함
  - 예를 들어, resource1을 생성하고, resource1의 정보를 활용해서 resource2를 생성한다면, 닫을 때는 그 반대인 resource2를 먼저 닫고, 그 다음에 resource1을 닫아야 함
    + resource2 입장에서 resouce1의 정보를 아직 참고하고 있기 때문임
  - 이 예제에서는 두 자원이 서로 관련이 없기 때문에, 생성과 종료 순서가 크게 상관이 없지만, resource1의 정보를 기반으로 resource2를 생성한다고 가정

5. 실행 결과
```
resource1 call
resource2 call Ex
CallException 예외 처리
Exception in thread "main" java.lang.RuntimeException: network.tcp.autoclosable.CallException: resource2 ex
	at network.tcp.autoclosable.ResourceCloseMainV1.main(ResourceCloseMainV1.java:9)
Caused by: network.tcp.autoclosable.CallException: resource2 ex
	at network.tcp.autoclosable.ResourceV1.callEx(ResourceV1.java:16)
	at network.tcp.autoclosable.ResourceCloseMainV1.logic(ResourceCloseMainV1.java:21)
	at network.tcp.autoclosable.ResourceCloseMainV1.main(ResourceCloseMainV1.java:6)
```
  - callEx() 호출하면서 예외 발생
  - 예외 때문에 자원 정리 코드가 정상 호출되지 않음
  - 즉, 예외가 발생하면 자원 정리가 되지 않는 문제 발생

-----
### 자원 정리2
-----
1. 예외가 발생하도 자원 정리가 되도록 설정
2. ResourceCloseMain2 (tcp/closable)
```java
package network.tcp.autoclosable;

public class ResourceCloseMainV2 {
    public static void main(String[] args) {
        try {
            logic();
        } catch (CallException e) {
            System.out.println("CallException 예외 처리");
            throw new RuntimeException(e);
        } catch (CloseException e) { // CloseException을 받음
            System.out.println("CloseException 예외 처리");
            throw new RuntimeException(e);
        }
    }

    private static void logic() throws CallException, CloseException {
        ResourceV1 resource1 = null; // 초기 선언은 null로 초기화
        ResourceV1 resource2 = null; // 초기 선언은 null로 초기화

        try {
            // 객체를 생성하는 경우에도 예외 발생 가능성 존재하므로 try ~ catch ~ fianlly 문 안에 선언해야 함
            resource1 = new ResourceV1("resource1"); // 만약 예외가 발생하면,
            resource2 = new ResourceV1("resource2"); // resource1의 예외로 인해 생성되지 않음

            resource1.call();
            resource2.callEx(); // CallException
        } catch (CallException e) { // CallException 예외 처리
            System.out.println("ex: " + e);
            throw e; // 예외 던짐
        } finally {  // CallException 예외 처리 후, fianlly로 이동
            if(resource2 != null) { // 위의 객체 생성 예외 경우를 대비해, 조건문
                resource2.closeEx(); // 자원 정리 단계에서 CloseException 발생 -> CloseException이 던져짐 (CallException이 아님) -> resoruce1 자원 정리 불가
            }

            if(resource1 != null) { // 위의 객체 생성 예외 경우를 대비해, 조건문
                resource1.closeEx(); // 호출되지 않음
            }
        }
    }
}
```

3. 실행 결과
```
resource1 call
resource2 call Ex
ex: network.tcp.autoclosable.CallException: resource2 ex
resource2 closeEx
CloseException 예외 처리
Exception in thread "main" java.lang.RuntimeException: network.tcp.autoclosable.CloseException: resource2 ex
	at network.tcp.autoclosable.ResourceCloseMainV2.main(ResourceCloseMainV2.java:12)
Caused by: network.tcp.autoclosable.CloseException: resource2 ex
	at network.tcp.autoclosable.ResourceV1.closeEx(ResourceV1.java:25)
	at network.tcp.autoclosable.ResourceCloseMainV2.logic(ResourceCloseMainV2.java:32)
	at network.tcp.autoclosable.ResourceCloseMainV2.main(ResourceCloseMainV2.java:6)
```

4. Null 체크
   - finally 코드 블록을 사용해서 자원을 닫는 코드 항상 호출하도록 설정
   - 만약, resource2 객체를 생성하기 전에 에외가 발생하면 resource2는 null이므로 null 체크를 해야 함
   - resourc1의 경우에도 resource1을 생성하는 중에 예외가 발생한다면 null 체크 필요

5. 자원 정리 중 예외가 발생하는 문제
   - finally 코드 블록은 항상 호출되므로 자원이 잘 정리될 것 같지만, 이번에는 자원을 정리하는 중에 fianlly 코드 블록 안에 resource2.closeEx()를 호출하면서 예외 발생
   - 결과적으로, resource1.closeEx()는 호출되지 않음

6. 핵심 예외가 바뀌는 문제
   - 코드에서 발생한 핵심적 예외는 CallException (이 예외로 인해 문제발생)
   - 그런데 finally 코드 블록에서 자원을 정리하면서 CloseException 예외가 추가로 발생
   - 예외 때문에 자원을 정리하고 있는데, 자원 중리 중에 또 예외가 발생한 것
   - 💡 이 경우, logic()을 호출한 쪽에서는 핵심 예외인 CallException이 아니라 finally 블록에서 새로 생성된 CloseException을 받음 (핵심 예외가 사라짐)
   - 핵심 에외를 확인해야 제대로 된 문제를 찾을 수 있음 (자원을 닫는 중 발생한 예외는 부가 예외)

7. 정리
   - close() 시점에 실수로 예외를 던지면, 이후 다른 자원으 닫을 수 없는 문제발생
   - fianlly 블록 안에서 자원을 닫을 때 예외가 발생하면, 핵심 예외가 finally 에서 발생한 부가 예외로 바뀌어버리고, 핵심 예외가 사라짐
