-----
### 임계 영역
-----
1. 문제 발생 원인 : 스레드가 함께 사용하는 공유 자원을 여러 단계로 나누어 사용하기 때문임
   - 검증 단계 : 잔액(balance)이 출금액(amount)보다 많은지 확인
   - 출금 단계 : 잔액(balance)을 출금액(amount)만큼 줄임

```java
출금() {
  1. 검증 단계: 잔액(balance) 확인
  2. 출금 단계: 잔액(balance) 감소
}
```

2. 위 로직에서의 하나의 가정
   - 스레드 하나의 관점에서 출금() 을 보면,
     + ```1.``` 검증 단계에서 확인한 잔액(balance) 1000원은
     + ```2.``` 출금 단계에서 계산을 끝마칠 때 까지 같은 1000원으로 유지되어야 함
   - 그래야 검증 단계에서 확인한 금액으로, 출금 단계에서 정확한 잔액을 계산할 수 있음
   - 그래야 검증 단계에서 확인한 1000원에 800원을 차감해서 200원이라는 잔액을 정확하게 계산할 수 있음
   - 결국 여기서는 사용하는 값이 중간에 변경되지 않을 것이라는 가정
   - 그런데 만약 중간에 다른 스레드가 잔액의 값을 변경한다면, 큰 혼란이 발생 : 1000원이라 생각한 잔액이 다른 값으로 변경되면 잔액이 전혀 다른 값으로 계산될 수 있음

3. 공유 자원
   - 잔액(balance)은 여러 스레드가 함께 사용하는 공유 자원
   - 따라서 출금 로직을 수행하는 중간에 다른 스레드에서 이 값을 얼마든지 변경할 수 있음
   - 참고로 여기서는 출금() 메서드를 호출할 때만 잔액(balance)의 값이 변경
   - 따라서 다른 스레드가 출금 메서드를 호출하면서, 사용중인 출금 값을 중간에 변경해 버릴 수 있음

4. 한 번에 하나의 스레드만 실행
   - 만약 출금() 이라는 메서드를 한 번에 하나의 스레드만 실행할 수 있게 제한한다면 어떻게 될까?
   - 예를 들어 t1, t2 스레드가 함께 출금()을 호출하면 t1 스레드가 먼저 처음부터 끝까지 출금() 메서드를 완료하고, 그 다음에 t2 스레드가 처음부터 끝까지 출금() 메서드를 완료하는 것
   - 이렇게 하면 공유 자원인 balance를 한 번에 하나의 스레드만 변경할 수 있음
   - 따라서 계산 중간에 다른 스레드가 balance의 값을 변경하는 부분을 걱정하지 않아도 됨 (참고로 여기서는 출금() 메서드를 호출할 때만 잔액(balance)의 값이 변경)
      + 더 자세히는 출금을 진행할 때 잔액(balance)을 검증하는 단계부터 잔액의 계산을 완료할 때 까지 잔액의 값은 중간에 변하면 안 됨
      + 이 검증과 계산 이 두 단계는 한 번에 하나의 스레드만 실행해야 함
      + 그래야 잔액(balance)이 중간에 변하지 않고, 안전하게 계산을 수행할 수 있음

5. 💡 임계 영역 (Critical Section)
   - 여러 스레드가 동시에 접근하면 데이터 불일치나 예상치 못한 동작이 발생할 수 있는 위험하고 또 중요한 코드 부분
   - 여러 스레드가 동시에 접근해서는 안 되는 공유 자원을 접근하거나 수정하는 부분을 의미 (예) 공유 변수나 공유 객체 수정)
   - 위에서는 출금() 로직이 임계 영역
     + 더 자세히는 출금을 진행할 때 잔액(balance)을 검증하는 단계부터 잔액의 계산을 완료할 때 까지가 임계 영역

   - 여기서 balance는 여러 스레드가 동시에 접근해서는 안되는 공유 자원
   - 이런 임계 영역은 한 번에 하나의 스레드만 접근할 수 있도록 안전하게 보호해야 함
   - 자바는 synchronized 키워드를 통해 아주 간단하게 임계 영역을 보호할 수 있음
