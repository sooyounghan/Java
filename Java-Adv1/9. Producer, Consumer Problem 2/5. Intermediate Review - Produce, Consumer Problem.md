-----
### 중간 정리 - 생산자 소비자 문제
-----
1. BoundedQueueV1
   - 단순한 큐 자료 구조
   - 스레드를 제어할 수 없기 때문에, 버퍼가 가득 차거나, 버퍼에 데이터가 없는 한정된 버퍼 상황에서 문제가 발생
   - 버퍼가 가득 찬 경우 : 생산자의 데이터를 버림
   - 버퍼에 데이터가 없는 경우 : 소비자는 데이터를 획득할 수 없음 (null)

2. BoundedQueueV2
   - 앞서 발생한 문제를 해결하기 위해 반복문을 사용해서 스레드를 대기하는 방법을 적용
   - 하지만 synchronized 임계 영역 안에서 락을 들고 대기하기 때문에, 다른 스레드가 임계 영역에 접근할 수 없는 문제가 발생
   - 결과적으로 나머지 스레드는 모두 BLOCKED 상태가 되고, 자바 스레드 세상이 멈추는 심각한 문제가 발생
    
3. BoundedQueueV3
   - synchronized 와 함께 사용할 수 있는 wait(), notify(), notifyAll()을 사용해서 문제를 해결
   - wait()를 사용하면 스레드가 대기할 때, 락을 반납하고 대기
   - 이후에 notify()를 호출하면 스레드가 깨어나면서 락 획득을 시도
   - 이 때, 락을 획득하면 RUNNABLE 상태가 되고, 락을 획득하지 못하면 락 획득을 대기하는 BLOCKED 상태
   - 이렇게 해서 스레드를 제어하는 큐 자료 구조를 만들 수 있었음
   - 생산자 스레드는 버퍼가 가득차면 버퍼에 여유가 생길 때 까지 대기
   - 소비자 스레드는 버퍼에 데이터가 없으면 버퍼에 데이터가 들어올 때 까지 대기
   - 이런 구현 덕분에 단순한 자료 구조를 넘어서 스레드까지 제어할 수 있는 자료 구조를 완성
   - 이 방식의 단점은 스레드가 대기하는 대기 집합이 하나이기 때문에, 원하는 스레드를 선택해서 깨울 수 없다는 문제가 있었음
      + 예를 들어서 생산자는 데이터를 생산한 다음 대기하는 소비자를 깨워야 하는데, 대기하는 생산자를 깨울 수 있음
      + 따라서 비효율이 발생. 물론 이렇게 해도 비효율이 있을 뿐 로직은 모두 정상 작동

4. BoundedQueueV4
   - synchronized와 wait(), notify()를 사용해서 구현하면 스레드 대기 집합이 하나라는 단점
   - 이 단점을 극복하려면 스레드 대기 집합을 생산자 전용과 소비자 전용으로 나누어야 함
   - 이렇게 하려면 Lock(ReentrantLock)을 사용
   - 여기서는 단순히 synchronized와 wait(), notify() 사용해서 구현한 코드를 Lock(ReentrantLock)를 사용하도록 변경

5. BoundedQueueV5
   - Lock(ReentrantLock)는 Condition이라는 스레드 대기 공간을 제공
   - 이 스레드 대기 공간을 원하는 만큼 따로 만들 수 있음
      + productCond : 생산자 스레드를 위한 전용 대기 공간
      + consumerCond : 소비자 스레드를 위한 전용 대기 공간

   - 덕분에 생산자가 데이터를 생산하고 나면 consumerCond.signal() 메서드를 통해 소비자 전용 대기 공간에 이 사실을 알릴 수 있음
   - 반대로 소비자가 데이터를 소비하고 나면 productCond.signal()을 통해 생산자 전용 대기 공간에 이 사실을 알릴 수 있음
   - 이렇게 스레드 대기 공간을 나누어서 앞서 synchronized, wait(), notify()를 사용한 방식에서 발생한 비효율 문제를 깔끔하게 해결할 수 있음

6. 우리가 함께 완성한 BoundedQueueV5는 생산자 소비자 문제, 또는 한정된 버퍼라고 알려진 문제를 매우 효율적으로 해결할 수 있는 자료 구조
   - 이 자료 구조는 단순한 큐의 기능을 넘어서 스레드를 효과적으로 제어하는 기능도 포함
   - 만약 멀티스레드 상황에서 생산자 소비자 문제가 나타난다면 우리가 만든 BoundedQueueV5를 사용
   - 이것은 큐 자료 구조인데, 여기에 한정된 버퍼 문제를 해결하기 때문에 앞에 Bounded 라는 이름을 붙임

-----
### BlockingQueue
-----
1. BlockingQueue를 스레드 관점에서보면 큐가 특정 조건이 만족될 때 까지 스레드 작업을 차단(blocking)
   - 데이터 추가 차단 : 큐가 가득차면, 데이터 추가 작업(put())을 시도하는 스레드 공간이 생길 때 까지 차단
   - 데이터 획득 차단 : 큐가 비어있으면, 획득 작업(take())을 시도하느 스레드는 큐에 데이터가 들어올 때까지 차단

2. 그래서 스레드 관점에서 이 큐에 이름을 지어보면 BlockingQueue라는 이름이 적절
  - 자바는 생산자 소비자 문제, 또는 한정된 버퍼라고 불리는 문제를 해결하기 위해 java.util.concurrent.BlockingQueue라는 인터페이스와 구현체들을 제공
