-----
### Executor 예외 정책
-----
1. 생산자 소비자 문제를 실무에서 사용할 때는, 결국 소비자가 처리할 수 없을 정도로 생산 요청이 가득 차면 어떻게 할지를 정해야 함
2. 인지할 수 있게 로그도 남겨야 하고, 사용자에게 현재 시스템에 문제가 있다고 알리는 것도 필요
3. 이런 것을 위해 예외 정책이 필요
  - ThreadPoolExecutor에 작업을 요청할 때, 큐도 가득차고, 초과 스레드도 더는 할당할 수 없다면 작업을 거절
  - ThreadPoolExecutor는 작업을 거절하는 다양한 정책을 제공
    + AbortPolicy : 새로운 작업을 제출할 때 RejectedExecutionException을 발생시킴 (기본 정책)
    + DiscardPolicy : 새로운 작업을 조용히 버림
    + CallerRunsPolicy : 새로운 작업을 제출한 스레드가 대신해서 직접 작업을 실행
    + 사용자 정의(RejectedExecutionHandler) : 직접 정의한 거절 정책을 사용할 수 있음

  - 참고로 ThreadPoolExecutor를 shutdown()하면 이후에 요청하는 작업을 거절하는데, 이때도 같은 정책이 적용

4. AbortPolicy : 작업이 거절되면 RejectedExecutionException 을 던지는 기본적으로 설정되어 있는 정책
  - RejectMainV1 (/thread/executor/reject)
```java
package thread.executor.reject;

import thread.executor.RunnableTask;

import java.util.concurrent.RejectedExecutionException;
import java.util.concurrent.SynchronousQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

import static thread.util.MyLogger.log;

public class RejectMainV1 {
    public static void main(String[] args) {
        ThreadPoolExecutor es = new ThreadPoolExecutor(1, 1, 0, TimeUnit.SECONDS, new SynchronousQueue<>(), new ThreadPoolExecutor.AbortPolicy());

        es.submit(new RunnableTask("task1"));
        try {
            es.submit(new RunnableTask("task2"));
        } catch (RejectedExecutionException e) {
            log("요청 초과");
            // 포기 또는 다시 시도 로직 추가하면 됨
            log(e);
        }

        es.close();
    }
}
```
  - ThreadPoolExecutor 생성자 마지막에 new ThreadPoolExecutor.AbortPolicy()를 제공
  - 기본 정책이기 때문에 생략 가능
  - 스레드는 1개만 사용 : 예제를 단순하게 만들기 위해 큐에 작업을 넣지 않도록 SynchronousQueue를 사용
  - 실행 결과
```
17:42:55.171 [pool-1-thread-1] task1 시작
17:42:55.171 [     main] 요청 초과
17:42:55.175 [     main] java.util.concurrent.RejectedExecutionException: Task java.util.concurrent.FutureTask@b1bc7ed[Not completed, task = java.util.concurrent.Executors$RunnableAdapter@1ddc4ec2[Wrapped task = thread.executor.RunnableTask@133314b]] rejected from java.util.concurrent.ThreadPoolExecutor@5b6f7412[Running, pool size = 1, active threads = 1, queued tasks = 0, completed tasks = 0]
17:42:56.189 [pool-1-thread-1] task1 완료
```

  - task1은 풀의 스레드가 수행
  - task2를 요청하면 허용 작업을 초과하므로, RejectedExecutionException 발생
  - RejectedExecutionException 예외를 잡아서 작업을 포기하거나, 사용자에게 알리거나, 다시 시도 하면 됨
  - 즉, 예외를 잡아서 필요 코드 직접 구현 또는 다른 정책 사용해도 됨

5. RejectedExecutionHandler
  - 마지막에 전달한 AbortPolicy는 RejectedExecutionHandler의 구현체
  - ThreadPoolExecutor 생성자는 RejectedExecutionHandler의 구현체를 전달
```java
public interface RejectedExecutionHandler {
    void rejectedExecution(Runnable r, ThreadPoolExecutor executor);
}
```
```java
public static class AbortPolicy implements RejectedExecutionHandler {
    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
        throw new RejectedExecutionException("Task " + r.toString() + " rejected from " + e.toString());
    }
}
```
  - ThreadPoolExecutor는 거절해야 하는 상황이 발생하면 여기에 있는 rejectedExecution()을 호출
  - AbortPolicy는 RejectedExecutionException을 던지는 것을 확인

6. DiscardPolicy : 거절된 작업을 무시하고 아무런 예외도 발생시키지 않음
  - RejectMainV2
```java
package thread.executor.reject;

import thread.executor.RunnableTask;

import java.util.concurrent.RejectedExecutionException;
import java.util.concurrent.SynchronousQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

import static thread.util.MyLogger.log;

public class RejectMainV2 {
    public static void main(String[] args) {
        ThreadPoolExecutor es = new ThreadPoolExecutor(1, 1, 0, TimeUnit.SECONDS, new SynchronousQueue<>(), new ThreadPoolExecutor.DiscardPolicy());

        es.submit(new RunnableTask("task1"));
        es.submit(new RunnableTask("task2"));
        es.submit(new RunnableTask("task3"));
        try {
            es.submit(new RunnableTask("task2"));
        } catch (RejectedExecutionException e) {
            log("요청 초과");
            // 포기 또는 다시 시도 로직 추가하면 됨
            log(e);
        }

        es.close();
    }
}
```
  - ThreadPoolExecutor 생성자 마지막에 new ThreadPoolExecutor.DiscardPolicy()를 제공
  - 실행 결과
```
17:48:39.142 [pool-1-thread-1] task1 시작
17:48:40.162 [pool-1-thread-1] task1 완료
```

  - task2, task3은 거절
  - DiscardPolicy는 조용히 버리는 정책
  - 다음 구현 코드를 보면 왜 조용히 버리는 정책인지 이해가 될 것
```java
public static class DiscardPolicy implements RejectedExecutionHandler {
    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
        // empty
    }
}
```
