-----
### 정리
-----  
1. BoundedQueueV1
  - 단순한 큐 자료 구조
  - 스레드를 제어할 수 없기 때문에, 버퍼가 가득 차거나, 버퍼에 데이터가 없는 한정된 버퍼 상황에서 문제가 발생
  - 버퍼가 가득 찬 경우 : 생산자의 데이터를 버림
  - 버퍼에 데이터가 없는 경우 : 소비자는 데이터를 획득할 수 없음 (null)

2. BoundedQueueV2
  - 앞서 발생한 문제를 해결하기 위해 반복문을 사용해서 스레드를 대기하는 방법을 적용
  - 하지만 synchronized 임계 영역 안에서 락을 들고 대기하기 때문에, 다른 스레드가 임계 영역에 접근할 수 없는 문제가 발생
  - 결과적으로 나머지 스레드는 모두 BLOCKED 상태가 되고, 자바 스레드 세상이 멈추는 심각한 문제가 발생
    
3. BoundedQueueV3
   - synchronized 와 함께 사용할 수 있는 wait(), notify(), notifyAll()을 사용해서 문제를 해결
   - wait()를 사용하면 스레드가 대기할 때, 락을 반납하고 대기
   - 이후에 notify()를 호출하면 스레드가 깨어나면서 락 획득을 시도
   - 이 때, 락을 획득하면 RUNNABLE 상태가 되고, 락을 획득하지 못하면 락 획득을 대기하는 BLOCKED 상태
   - 이렇게 해서 스레드를 제어하는 큐 자료 구조를 만들 수 있었음
   - 생산자 스레드는 버퍼가 가득차면 버퍼에 여유가 생길 때 까지 대기
   - 소비자 스레드는 버퍼에 데이터가 없으면 버퍼에 데이터가 들어올 때 까지 대기
   - 이런 구현 덕분에 단순한 자료 구조를 넘어서 스레드까지 제어할 수 있는 자료 구조를 완성
   - 이 방식의 단점은 스레드가 대기하는 대기 집합이 하나이기 때문에, 원하는 스레드를 선택해서 깨울 수 없다는 문제가 있었음
      + 예를 들어서 생산자는 데이터를 생산한 다음 대기하는 소비자를 깨워야 하는데, 대기하는 생산자를 깨울 수 있음
      + 따라서 비효율이 발생. 물론 이렇게 해도 비효율이 있을 뿐 로직은 모두 정상 작동

4. 자바 synchronized와 Object.wait(), Object.notify(), Object.notifyAll()을 사용해서 생산자 소비자 문제를 해결
5. 이 기술을 사용한 덕분에 생산자는 큐에 데이터가 가득 차 있어도, 큐에 데이터를 저장할 공간이 생길 때 까지 대기할 수 있음
6. 소비자도 큐에 데이터가 없어도, 큐에 데이터가 들어올 때 까지 대기할 수 있었다. 결과적으로 버리는 데이터 없이 안전하게 데이터를 큐에 보관하고 또 소비할 수 있음
7. 하지만 이 방법은 일부 비효율이 발생
  - 생산자 스레드는 데이터를 생성하고, 대기중인 소비자 스레드에게 알려주어야 함
  - 소비자 스레드는 데이터를 소비하고, 대기중인 생산자 스레드에게 알려주어야 함
  - 하지만 스레드 대기 집합은 하나이고 이 안에 생산자 스레드와 소비자 스레드가 함께 대기
  - 그리고 notify()는 원하는 목표를 지정할 수 없음
  - 물론 notifyAll()을 사용할 수 있지만, 원하지 않는 모든 스레드까지 모두 깨어남
