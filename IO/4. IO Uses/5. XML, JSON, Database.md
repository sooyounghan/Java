-----
### 객체 직렬화의 한계
-----
1. 객체 직렬화를 사용하지 않는 이유
   - 버전 관리 어려움 : 클래스 구조가 변경되면 이전 직렬화된 객체와의 호환성 문제 발생 및 serialVersionUID 관리 복잡
   - 플랫폼 종속성 : 자바 직렬화는 자바 플랫폼에 종속적이어서 다른 언어나 시스템과 상호 운용성이 떨어짐
   - 성능 이슈 : 직렬화 / 역직렬화 과정이 상대적으로 느리고 리소스 많이 사용
   - 유연성 부족 : 직렬화된 형식을 커스텀마이즈하기 어려움
   - 크기 효율성 : 직렬화된 데이터 크기가 상대적으로 큼

2. 객체 직렬화의 대안 1 - XML
```xml
<member>
  <id>id1</id>
  <name>name1</name>
  <age>20</age>
</member>
```
  - 플랫폼 종속성 문제 해결을 위해 2000년대 초반에 XML 기술 인기를 얻음
  - XML은 매우 유연하고 강력하지만, 복잡성과 무거움이라는 문제 존재
  - 태그를 포함한 XML 문서 크기가 커서 네트워크 전송 비용 증가

3. 객체 직렬화의 대안 2 - JSON
```json
{
  "member": {
              "id": "id1",
              "name": "name1",
              "age": 20
            }
}
```
  - 가볍고 간결하며, 자바스크립트와 자연스러운 호환성 덕분에 웹 개발자들 사이에서 빠르게 확산
  - 2000년대 후반, 웹 API와 RESTful 서비스가 대중화되면서 표준 데이터 교환 포맷으로 자리잡읍

4. XML은 데이터 구조의 복잡성과 엄격한 스키마 정의가 필요한 초기 웹 서비스와 엔터프라이즈 환경에서 중요한 역할을 헀지만, 시간이 지나면서 JSON과 같은 가볍고 효율적인 데이터 형식이 더 많이 채택
5. JSON은 웹과 모바일 애플리케이션 발전과 함께 급속히 인기를 얻었으며, 현재 대부분 데이터 교환에서 기본 포맷으로 사용
6. XML은 특정 영역에서 여전히 사용되지만, JSON은 현대 소프트웨어 개발 주류로 자리 잡음
7. 즉, 웹 환경에서 데이터 교환 시, JSON이 사실상 표준 기술

8. 객체 직렬화의 대안 3 - Protobuf, Avro : 더 적은 용량, 더 빠른 성능
   - JSON은 거의 모든 곳에 호환이 가능하고, 사람이 읽고 쓰기 쉬운 텍스트 기반 포맷이어서 디버깅과 개발이 쉬움
   - 만약, 매우 작은 용량으로 더 빠른 속도가 필요하다면, Protobuf, Avro 같은 대안 기술 존재
   - 이 기술들은 호환성은 떨어지지만 byte 기반에 용량과 성능 최적화가 되어있어 매우 빠름
   - 다만, byte 기반으므로 JSON처럼 사람이 직접 읽기 어려움

9. 정리
    - 자바 객체 직렬화는 대부분 사용하지 않음
    - JSON이 사실상 표준이므로, 먼저 고려
    - 성능 최적화가 매우 중요하다면 Protobuf, Avro 같은 기술 고려 (JSON만으로도 충분히 가능)

   
