-----
### 컨텍스트 스위칭 (Context Switching)
-----
1. 컴퓨터의 멀티 태스킹
   - CPU 코어는 하나만 있다고 가정, 스레드A, 스레드B 존재
     + 운영체제는 먼저 스레드A를 실행
     + 멀티태스킹을 해야 하기 때문에 스레드A를 계속 실행할 수 없음
     + 스레드A를 잠시 멈추고, 스레드B를 실행
     + 이후에 스레드A로 그냥 돌아갈 수 없음
     + CPU에서 스레드를 실행하는데, 스레드A의 코드가 어디까지 수행되었는지 위치를 찾아야 함
     + 그리고 계산하던 변수들의 값을 CPU에 다시 불러들여야 함
     + 따라서 스레드A를 멈추는 시점에 CPU에서 사용하던 이런 값들을 메모리에 저장해두어야 하며, 이후에 스레드A를 다시 실행할 때 이 값들을 CPU에 다시 불러와야 함

  - 이런 과정을 컨텍스트 스위칭(context switching)
     + 컨텍스트는 현재 작업하는 문맥을 뜻함
     + 현재 작업하는 문맥이 변하기 때문에 컨텍스트 스위칭
     + 컨텍스트 스위칭 과정에서 이전에 실행 중인 값을 메모리에 잠깐 저장하고, 이후에 다시 실행하는 시점에 저장한 값을 CPU에 다시 불러와야 함
     + 결과적으로 컨텍스트 스위칭 과정에는 약간의 비용이 발생

2. 멀티스레드는 대부분 효율적이지만, 컨텍스트 스위칭 과정이 필요하므로 항상 효율적인 것은 아님
   - 예를 들어서 1 ~ 10000까지 더해야 한다고 가정
   - 이 문제는 둘로 나눌 수 있음
      + 스레드1: 1 ~ 5000까지 더함
      + 스레드2: 5001 ~ 10000까지 더함
      + 마지막에 스레드1의 결과와 스레드2의 결과를 더함

   - CPU 코어가 2개
      + CPU 코어가 2개 있다면 스레드1, 스레드2로 나누어 멀티스레드로 병렬 처리하는게 효율적
      + 모든 CPU를 사용하므로 연산을 2배 빠르게 처리할 수 있음

   - CPU 코어가 1개
      + CPU 코어가 1개 있는데, 스레드를 2개로 만들어서 연산하면 중간중간 컨텍스트 스위칭 비용이 발생
      + 운영체제 스케줄링 방식에 따라서 다르겠지만, 스레드1을 1 ~ 1000 정도까지 연산한 상태에서 잠시 멈추고 스레드2를 5001 ~ 6001까지 연산하는 식으로 반복할 수 있음
      + 이때 CPU는 스레드1을 멈추고 다시 실행할 때 어디까지 연산했는지 알아야 하고, 그 값을 CPU에 다시 불러와야 함
      + 결과적으로 이렇게 반복할 때 마다 컨텍스트 스위칭 비용(시간)이 들어감
      + 결과적으로 연산 시간 + 컨텍스트 스위칭 시간 발생
    
    - 이런 경우 단일 스레드로 1 ~ 10000까지 더하는 것이 컨텍스트 스위칭 비용 없이, 연산 시간만 사용하기 때문에 더 효율적
    - 실제로 컨텍스트 스위칭에 걸리는 시간은 아주 짧음
    - 하지만 스레드가 매우 많다면 이 비용이 커질 수 있음
    - 물론 최신 CPU는 초당 수 십억 단위를 계산하기 때문에 실제로는 계산에 더 큰 숫자를 사용해야 컨텍스트 스위칭이 발생

  3. 참고 - 실무 이야기
     - CPU - 4개, 스레드 2개 : 스레드의 숫자가 너무 적으면 모든 CPU를 100% 다 활용할 수 없지만, 스레드가 몇 개 없으므로 컨텍스트 스위칭 비용이 줄어듬
     - CPU - 4개, 스레드 100개 : 스레드의 숫자가 너무 많으면 CPU를 100% 다 활용할 수 있지만 컨텍스트 스위칭 비용이 늘어남
     - CPU - 4개, 스레드 4개 : 스레드의 숫자를 CPU의 숫자에 맞춘다면 CPU를 100% 활용할 수 있고, 컨텍스트 스위칭 비용도 자주 발생하지 않기 때문에 최적의 상태
       + 이상적으로는 CPU 코어 수 + 1개 정도로 스레드를 맞추면 특정 스레드가 잠시 대기할 때 남은 스레드를 활용할 수 있음

     - CPU 바운드 작업 vs I/O 바운드 작업 : 각각의 스레드가 하는 작업은 크게 2가지로 구분 가능
     - CPU-바운드 작업 (CPU-bound tasks) : CPU의 연산 능력을 많이 요구하는 작업을 의미
        + 이러한 작업은 주로 계산, 데이터 처리, 알고리즘 실행 등 CPU의 처리 속도가 작업 완료 시간을 결정하는 경우
        + 예시 : 복잡한 수학 연산, 데이터 분석, 비디오 인코딩, 과학적 시뮬레이션 등

     - I/O-바운드 작업 (I/O-bound tasks) : 디스크, 네트워크, 파일 시스템 등과 같은 입출력(I/O) 작업을 많이 요구하는 작업을 의미
        + 이러한 작업은 I/O 작업이 완료될 때까지 대기 시간이 많이 발생하며, CPU는 상대적으로 유휴(대기) 상태에 있는 경우가 많음
        + 쉽게 이야기해서 스레드가 CPU를 사용하지 않고 I/O 작업이 완료될 때 까지 대기
        + 예시 : 데이터베이스 쿼리 처리, 파일 읽기/쓰기, 네트워크 통신, 사용자 입력 처리 등.

     - 웹 애플리케이션 서버
        + 분야마다 다르겠지만, 실무에서는 CPU-바운드 작업 보다는 I/O-바운드 작업이 많음
        +  예를 들어서 백엔드 개발자의 경우 주로 웹 애플리케이션 서버를 개발하는데, 스레드가 1 ~ 10000까지 더하는 CPU의 연산이 필요한 작업보다는, 대부분 사용자의 입력을 기다리거나, 데이터베이스를 호출하고 그 결과를 기다리는 등, 기다리는 일이 많음
        + 쉽게 이야기해서 스레드가 CPU를 많이 사용하지 않는 I/O-바운드 작업이 많다는 뜻
        + 일반적인 자바 웹 애플리케이션 서버의 경우 사용자의 요청 하나를 처리하는데 1개의 스레드가 필요
        + 사용자 4명이 동시에 요청하면 4개의 스레드가 작동하는 것
        + 그래야 4명의 사용자의 요청을 동시에 처리할 수 있음
        + 사용자의 요청을 하나 처리하는데, 스레드는 CPU를 1% 정도 사용하고, 대부분 데이터베이스 서버에 어떤 결과를 조회 하면서 기다린다고 가정
        + 이때는 스레드는 CPU를 거의 사용하지 않고 대기하는데, 바로 I/O-바운드 작업이 많다는 것
        + 이 경우 CPU 코어가 4개 있다고해서 스레드 숫자도 CPU 코어에 맞추어 4개로 설정하면 안 됨
        + 그러면 동시에 4명의 사용자 요청만 처리할 수 있음
        + 이 때 CPU는 단순하게 계산해서 4% 정도만 사용할 것이므로, 결국 사용자는 동시에 4명 밖에 못받지만 CPU는 4%만 사용하며 CPU가 놀고 있는 사태가 벌어질 수 있음
        + 사용자의 요청 하나를 처리하는데 CPU를 1%만 사용한다면 단순하게 생각해도 100개의 스레드를 만들 수 있음
        + 이렇게 하면 동시에 100명의 사용자 요청을 받을 수 있음
        + 물론 실무에서는 성능 테스트를 통해서 최적의 스레드 숫자를 찾는 것이 이상적
        + 정리하면 스레드의 숫자는 CPU-바운드 작업이 많은가, 아니면 I/O-바운드 작업이 많은가에 따라 다르게 설정

     - CPU-바운드 작업 : CPU 코어 수 + 1개
        + CPU를 거의 100% 사용하는 작업이므로 스레드를 CPU 숫자에 최적화

     - I/O-바운드 작업 : CPU 코어 수 보다 많은 스레드를 생성, CPU를 최대한 사용할 수 있는 숫자까지 스레드 생성
       + CPU를 많이 사용하지 않으므로 성능 테스트를 통해 CPU를 최대한 활용하는 숫자까지 스레드 생성
       + 단, 너무 많은 스레드를 생성하면 컨텍스트 스위칭 비용도 함께 증가 - 적절한 성능 테스트 필요

     - 참고로 웹 애플리케이션 서버라도 상황에 따라 CPU 바운드 작업이 많을 수 있음
     - 이 경우 CPU-바운드 작업에 최적화 된 CPU 숫자를 고려하면 됨
