-----
### 정리 - Lock vs CAS 사용 방식
-----
1. CAS의 장점
   - 낙관적 동기화
     + 락을 걸지 않고도 값을 안전하게 업데이트할 수 있음
     + CAS는 충돌이 자주 발생하지 않을 것이라고 가정
     + 이는 충돌이 적은 환경에서 높은 성능을 발휘
    
   - 락 프리(Lock-Free)
     + CAS는 락을 사용하지 않기 때문에, 락을 획득하기 위해 대기하는 시간이 없음
     + 따라서 스레드가 블로킹되지 않으며, 병렬 처리가 더 효율적일 수 있음

2. CAS의 단점
   - 충돌이 빈번한 경우
     + 여러 스레드가 동시에 동일한 변수에 접근하여 업데이트를 시도할 때 충돌이 발생할 수 있음
     + 충돌이 발생하면 CAS는 루프를 돌며 재시도해야 하며, 이에 따라 CPU 자원을 계속 소모할 수 있음
     + 반복적인 재시도로 인해 오버헤드가 발생할 수 있음

   - 스핀락과 유사한 오버헤드
     + CAS는 충돌 시 반복적인 재시도를 하므로, 이 과정이 계속 반복되면 스핀락과 유사한 성능 저하가 발생할 수 있음
     + 특히 충돌 빈도가 높을수록 이런 현상이 두드러짐

3. 동기화 락의 장점
   - 충돌 관리
     + 락을 사용하면 하나의 스레드만 리소스에 접근할 수 있으므로 충돌이 발생하지 않음
     + 여러 스레드가 경쟁할 경우에도 안정적으로 동작

   - 안정성 : 복잡한 상황에서도 락은 일관성 있는 동작을 보장
   - 스레드 대기 : 락을 대기하는 스레드는 CPU를 거의 사용하지 않음

4. 동기화 락의 단점
   - 락 획득 대기 시간 : 스레드가 락을 획득하기 위해 대기해야 하므로, 대기 시간이 길어질 수 있음
   - 컨텍스트 스위칭 오버헤드
     + 락을 사용하면, 락 획득을 대기하는 시점과 또 락을 획득하는 시점에 스레드의 상태가 변경
     + 이 때 컨텍스트 스위칭이 발생할 수 있으며, 이로 인해 오버헤드가 증가할 수 있음

5. 결론
  - 일반적으로 동기화 락을 사용하고, 아주 특별한 경우에 한정해서 CAS를 사용해서 최적화
  - CAS를 통한 최적화가 더 나은 경우는 스레드가 RUNNABLE → BLOCKED, WAITING 상태에서 다시 RUNNABLE 상태로 가는 것 보다는, 스레드를 RUNNABLE로 살려둔 상태에서 계속 락 획득을 반복 체크하는 것이 더 효율적인 경우에 사용
  - 하지만 이 경우 대기하는 스레드가 CPU 자원을 계속 소모하기 때문에 대기 시간이 아주 짧아야 함
  - 따라서 임계 영역이 필요는 하지만, 연산이 길지 않고 매우 짧게 끝날 때 사용해야 함
    + 예) 숫자 값의 증가, 자료 구조의 데이터 추가, 삭제와 같이 CPU 사이클이 금방 끝나지만 안전한 임계 영역, 또는 원자적인 연산이 필요한 경우에 사용
    + 예) 반면에 데이터베이스를 기다린다거나, 다른 서버의 요청을 기다리는 것 처럼 오래 기다리는 작업에 CAS를 사용하면 CPU를 계속 사용하며 기다리는 최악의 결과가 나올 수도 있음 - 이런 경우에는 동기화 락을 사용

  - 또한 CAS는 충돌 가능성이 낮은 환경에서 매우 효율적이지만, 충돌 가능성이 높은 환경에서는 성능 저하가 발생할 수 있음
  - 이런 경우에는 상황에 맞는 적절한 동기화 전략을 사용하는 것이 중요
  - 때로는 락이 더 나은 성능을 발휘할 수 있으며, CAS가 항상 더 빠르다고 단정할 수는 없음
  - 따라서, 각 접근 방식의 특성을 이해하고, 애플리케이션의 특정 요구사항과 환경에 맞는 방식을 선택하는 것이 필요

-----
### 실무 관점
-----
1. 실무 관점에서 보면 대부분의 애플리케이션들은 공유 자원을 사용할 때, 충돌할 가능성 보다 충돌하지 않을 가능성이 훨씬 높음
   - 예를 들어서 여러 스레드에서 발생하는 주문 수를 실시간으로 증가하면서 카운트 한다고 가정
   - 그리고 특정 피크시간에 주문이 100만건 들어오는 서비스라고 가정 (1,000,000 / 60분 = 1분에 16,666건, 1초에 277건)
   - CPU가 1초에 얼마나 많은 연산을 처리하는지 생각해보면, 백만 건 중에 충돌이 나는 경우는 아주 넉넉하게 해도 몇 십건 이하일 것
   - 따라서 실무에서는 주문 수 증가와 같은 단순한 연산의 경우, 락을 걸고 시작하는 것 보다는, CAS처럼 낙관적인 방식이 더 나은 성능을 보임

2. 그런데 여기서 중요한 핵심은 주문 수 증가와 같은 단순한 연산 경우에는 AtomicInteger 와 같은 CAS 연산을 사용하는 방식이 효과적 (나노 초 단위로 발생하는 연산)

3. 반면에 데이터베이스를 기다린다거나, 다른 서버의 요청을 기다리는 것 처럼 수 밀리초 이상의 시간이 걸리는 작업이라면 CAS를 사용하는 것 보다 동기화 락을 사용하거나 스레드가 대기하는 방식이 더 효과적
4. 자바 동시성 라이브러리들, 동기화 컬렉션들은 성능 최적화를 위해 CAS 연산을 적극 활용
5. 덕분에 실무에서 직접 CAS 연산을 사용하는 사용하는 일은 매우 드물며, 대신에 CAS 연산을 사용해서 최적화 되어 있는 라이브러리들을 이해하고 편리하게 사용할 줄 알면 충분
