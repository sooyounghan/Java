-----
### 컬렉션 프레임워크 전체 정리
-----
1. 자바 컬렉션 프레임워크 주요 기능
<div align="center">
<img src="https://github.com/user-attachments/assets/449a8564-4d8f-4308-b7c0-64481140b1c5">
</div>

   - 자바 컬렉션 프레임워크는 데이터 그룹을 저장하고 처리하기 위한 통합 아키텍처를 제공
   - 이 프레임워크는 인터페이스, 구현, 알고리즘으로 구성되어 있으며, 다양한 타입의 컬렉션을 효율적으로 처리할 수 있게 해줌
     + 컬렉션 : 객체의 그룹이나 집합을 의미
  
2. Collection 인터페이스의 필요성
   - Collection 인터페이스는 자바 컬렉션 프레임워크의 가장 기본적인 인터페이스로, 자바에서 데이터 그룹을 다루는데 필요한 가장 기본적인 메서드들을 정의
   - 그리고 다양한 컬렉션 타입들이 공통적으로 따라야 하는 기본 규약을 정의
   - List, Set, Queue 와 같은 더 구체적인 컬렉션 인터페이스들은 모두 Collection 인터페이스를 확장(extend)하여, 공통된 메서드들을 상속받고 추가적인 기능이나 특성을 제공
   - 이러한 설계는 자바 컬렉션 프레임워크의 일관성과 재사용성을 높여줌
      + 일관성 : 모든 컬렉션 타입들이 Collection 인터페이스를 구현함으로써, 모든 컬렉션들이 기본적인 동작을 공유한다는 것을 보장
        * 이는 다양한 타입의 컬렉션을 다룰 때 일관된 방식으로 접근할 수 있게 해줌
      + 재사용성 : Collection 인터페이스에 정의된 메서드들은 다양한 컬렉션 타입들에 공통으로 적용
        * 이는 코드의 재사용성을 높이고, 유지 보수를 용이하게 함
      + 확장성 : 새로운 컬렉션 타입을 만들 때 Collection 인터페이스를 구현함으로써, 기존에 정의된 알고리즘과 도구를 사용할 수 있음
        * 이는 프레임워크의 확장성을 향상
      + 다형성 : Collection 인터페이스를 사용함으로써, 다양한 컬렉션 타입들을 같은 타입으로 다룰 수 있음
        * 이는 다형성을 활용해서 유연한 코드를 작성할 수 있게 해줌

3. Collection 인터페이스의 주요 메서드
    - Collection 인터페이스에는 다음과 같은 주요 메서드들이 포함
      + add(E e) : 컬렉션에 요소를 추가
      + remove(Object o) : 주어진 객체를 컬렉션에서 제거
      + size() : 컬렉션에 포함된 요소의 수를 반환
      + isEmpty() : 컬렉션이 비어 있는지 확인
      + contains(Object o) : 컬렉션이 특정 요소를 포함하고 있는지 확인
      + iterator() : 컬렉션의 요소에 접근하기 위한 반복자를 반환
      + clear() : 컬렉션의 모든 요소를 제거

   - Collection은 Map 을 제외한 모든 컬렉션 타입의 부모
   - 따라서 모든 컬렉션을 받아서 유연하게 처리할 수 있음
   - 대표적으로 컬렉션 인터페이스는 iterator를 제공
   - 따라서 데이터를 단순히 순회할 목적이라면 Collection을 사용하면 모든 컬렉션 타입의 데이터를 순회할 수 있음

4. 컬렉션 프레임워크는 크게 인터페이스, 구현, 알고리즘을 제공
   - 인터페이스 : 자바 컬렉션 프레임워크의 핵심 인터페이스
     + Collection : 단일 루트 인터페이스로, 모든 컬렉션 클래스가 이 인터페이스를 상속 받음
        * List, Set, Queue 등의 인터페이스가 여기에 포함
     + List : 순서가 있는 컬렉션을 나타내며, 중복 요소를 허용, 인덱스를 통해 요소에 접근할 수 있음
        * 예) ArrayList, LinkedList
     + Set : 중복 요소를 허용하지 않는 컬렉션을 나타냄, 특정 위치가 없기 때문에 인덱스를 통해 요소에 접근할 수 없음
        * 예) HashSet, LinkedHashSet, TreeSet
     + Queue: 요소가 처리되기 전에 보관되는 컬렉션을 나타낸다.
        * 예) ArrayDeque , LinkedList , PriorityQueue
     + Map: 키와 값 쌍으로 요소를 저장하는 객체이다. Map 은 Collection 인터페이스를 상속받지 않는다.
        * 예) HashMap , LinkedHashMap , TreeMap

   - 구현 : 자바는 각 인터페이스의 여러 구현을 제공
     + List: ArrayList는 내부적으로 배열을 사용하며, LinkedList는 연결 리스트를 사용
     + Set: HashSet은 해시 테이블을, LinkedHashSet은 해시 테이블과 연결 리스트를, TreeSet은 레드-블랙 트리를 사용
     + Map: HashMap은 해시 테이블을, LinkedHashMap은 해시 테이블과 연결 리스트를, TreeMap은 레드-블랙 트리를 사용
     + Queue: LinkedList는 연결 리스트를 사용, ArrayDeque 는 배열 기반의 원형 큐를 사용
        * 대부분의 경우 ArrayDeque 가 빠름

   - 알고리즘
     + 컬렉션 프레임워크는 데이터를 처리하고 조작하기 위한 다양한 알고리즘을 제공
     + 이러한 알고리즘은 각각의 자료 구조 자체적으로 기능을 제공하기도 하고 또 Collections와 Arrays클래스에 정적 메소드 형태로도 구현되어 있기도 함
     + 이를 통해 정렬, 검색, 순환, 변환 등의 작업을 수행할 수 있음

5. 선택 가이드
    - 순서가 중요하고 중복이 허용되는 경우 : List 인터페이스를 사용
      + ArrayList 가 일반적인 선택
      + 추가 / 삭제 작업이 앞쪽에서 빈번한 경우에는 LinkedList가 성능상 더 좋은 선택
   - 중복을 허용하지 않고 순서가 중요하지 않은 경우 : HashSet 을 사용
      + 순서를 유지해야하면 LinkedHashSet을, 정렬된 순서가 필요하면 TreeSet을 사용
   - 요소를 키-값 쌍으로 저장하려는 경우 : Map 인터페이스를 사용
      + 순서가 중요하지 않다면 HashMap을, 순서를 유지해야 한다면 LinkedHashMap을, 정렬된 순서가 필요하면 TreeMap을 사용
   - 요소를 처리하기 전에 보관해야 하는 경우 : Queue , Deque 인터페이스를 사용
      + 스택, 큐 구조 모두 ArrayDeque 를 사용하는 것이 가장 빠름
      + 만약 우선순위에 따라 요소를 처리해야 한다면 PriorityQueue를 고려
      + 참고: PriorityQueue 는 자주 사용하지 않아서 따로 설명하지 않았다. 큐에 입력하는 요소에 우선순위를 부여할 수 있음

6. 실무 선택 가이드
    - List 의 경우 대부분 ArrayList 를 사용
    - LSet 의 경우 대부분 HashSet 을 사용
    - LMap 의 경우 대부분 HashMap 을 사용
    - LQueue 의 경우 대부분 ArrayDeque 를 사용
