-----
### 해시 알고리즘 - 해시 충돌
-----
1. 해시 충돌
  - 99, 9의 두 값은 10으로 나누면 9
  - 즉, 다른 값을 입력했지만 같은 해시 코드가 나오게 되는데 이것을 해시 충돌
```
99 % 10 = 9
9 % 10 = 9
```

2. 해시 충돌 시, 문제
<div align="center">
<img src="https://github.com/user-attachments/assets/90427b13-3f2e-4c2f-882f-c9d3ed3ae64b">
</div>

  - 먼저 99의 값을 저장 : 해시 인덱스는 9이므로 9번 인덱스에 99 값을 저장
  - 다음으로 9의 값을 저장 : 해시 인덱스는 9이므로 9번 인덱스에 9 값을 저장
  - 결과적으로 배열의 인덱스 9에는 처음에 저장한 값 99는 사라지고, 마지막에 저장한 값 9만 남게됨

3. 이 문제를 해결하는 가장 단순한 방법은 CAPACITY를 값의 입력 범위만큼 키우면 됨
   - 여기서는 99까지만 입력하므로 CAPACITY를 100으로 늘리면, 충돌이 발생하지 않음
   - 하지만 앞서 보았듯이 이 방법은 메모리 낭비가 심하고, 모든 int 숫자를 다 받는 문제를 해결할 수 없음

3. 해시 충돌 해결
  - 해시 충돌은 낮은 확률로 일어날 수 있다고 가정하는 것
  - 💡 해결 방안은 바로 해시 충돌이 일어났을 때 단순하게 같은 해시 인덱스의 값을 같은 인덱스에 함께 저장해버리는 것

4. 해시 충돌과 저장
<div align="center">
<img src="https://github.com/user-attachments/assets/042c19b3-4b5d-4965-9275-0e104ade9899">
</div>

  - 물론 여러 데이터를 배열의 하나의 공간에 함께 저장할 수는 없으므로, 배열 안에 배열을 생성
  - 물론 배열 안에 리스트 같은 다른 자료구조를 사용해도 됨

5. 해시 충돌과 조회
   - 해시 충돌이 난 경우 내부의 데이터를 하나씩 비교해보면 원하는 결과를 찾을 수 있음
   - 예를 들어 99를 조회한다고 가정

<div align="center">
<img src="https://github.com/user-attachments/assets/160cb64b-f33f-4422-ad64-2d2b8449e0d29">
</div>

  - 99의 해시 인덱스는 9이므로, 배열에서 9번 인덱스를 찾는다.
  - 배열 안에는 또 배열이 들어있으므로, 들어있는 모든 값을 검색할 값과 하나씩 비교
  - [99, 9]의 데이터가 들어있는데, 이를 비교하여 원하는 데이터를 찾을 수 있음

<div align="center">
<img src="https://github.com/user-attachments/assets/00982706-41f8-49de-baa5-b5a915ece4a3">
</div>

  - 9의 해시 인덱스는 9로서, 배열에서 9번 인덱스를 찾음
  - 배열 안에는 또 배열이 들어있으므로, 여기에 있는 모든 값을 검색할 값과 하나씩 비교
    + [99, 9]의 데이터가 들어있으므로, 첫 비교에서 99 equals 9 는 거짓이므로 실패
    +  다음 비교에서 9 equals 9 이므로 원하는 데이터를 찾음
  - 비교시 equals 를 사용했지만 기본형이라면 물론 == 을 사용해도 됨

6. 최악의 경우
<div align="center">
<img src="https://github.com/user-attachments/assets/7ade2aaf-9dc3-4f83-bfce-5cca158eca2d">
</div>

  - 값을 9, 19, 29, 99만 저장한다고 가정
    + 이 경우 모든 해시 인덱스가 9
  - 따라서 9번 인덱스에 데이터가 모두 저장
  - 이렇게 되면 데이터를 찾을 때 결국 9번에 가서 저장한 데이터의 수 만큼 값을 반복해서 비교해야 함
  - 따라서 최악의 경우 O(n)의 성능

7. 정리
  - 해시 인덱스를 사용하는 방식은 최악의 경우 O(n)의 성능
  - 하지만 확률적으로 보면 어느 정도 넓게 퍼지기 때문에 평균으로 보면 대부분 O(1)의 성능을 제공
  - 해시 충돌이 가끔 발생해도 내부에서 값을 몇 번만 비교하는 수준이기 때문에 대부분의 경우 매우 빠르게 값을 찾을 수 있음
