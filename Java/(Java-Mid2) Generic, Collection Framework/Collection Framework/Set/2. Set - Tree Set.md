-----
### 자바가 제공하는 Set 2 - TreeSet
-----
1. TreeSet
   - 구현 : TreeSet은 이진 탐색 트리를 개선한 레드-블랙 트리를 내부에서 사용
   - 순서 : 요소들은 정렬된 순서로 저장
     + 순서의 기준은 비교자(Comparator)로 변경할 수 있음
   - 시간 복잡도 : 주요 연산들은 O(log n) 의 시간 복잡도를 가지므로, 따라서 HashSet 보다는 느림
   - 용도 : 데이터들을 정렬된 순서로 유지하면서 집합의 특성을 유지해야 할 때 사용
     + 예를 들어, 범위 검색이나 정렬된 데이터가 필요한 경우에 유용
     + 💡 참고로 입력된 순서가 아니라 데이터 값의 순서
     + 예를 들어 3, 1, 2 를 순서대로 입력해도 1, 2, 3 순서로 출력

2. 트리 구조
<div align="center">
<img src="https://github.com/user-attachments/assets/b9339b56-308a-4591-bacd-432b61b3cbeb">
</div>

   - 트리는 부모 노드와 자식 노드로 구성
   - 가장 높은 조상을 루트(root)
   - 자식이 2개까지 올 수 있는 트리를 이진 트리
   - 여기에 노드의 왼쪽 자손은 더 작은 값을 가지고, 오른쪽 자손은 더 큰 값을 가지는 것을 이진 탐색 트리
   - TreeSet은 이진 탐색 트리를 개선한 레드-블랙 트리를 사용

3. 트리 구조의 구현
<div align="center">
<img src="https://github.com/user-attachments/assets/4867f23f-f6b4-4635-9ced-a45230cc8f1b">
</div>

```java
class Node {
    Object item;
    Node left;
    Node right;
}
```
  - 트리 구조는 왼쪽, 오른쪽 노드를 알고 있으면 됨

4. 이진 탐색 트리 - 입력 예시
   - 이진 탐색 트리의 핵심은 데이터를 입력하는 시점에 정렬해서 보관한다는 점
   - 그리고 작은 값은 왼쪽에 큰 값은 오른쪽에 저장
   - 데이터를 10, 5, 15, 1, 6, 11, 16 순서대로 입력한다고 가정
   - 처음에 10을 입력했다고 가정하고, 다음으로 5, 15를 입력
<div align="center">
<img src="https://github.com/user-attachments/assets/a44dce3e-d555-46b8-89ee-c1f6e451f723">
</div>

   - 5는 10보다 작으므로 왼쪽에 저장
   - 15는 10보다 크므로 오른쪽에 저장
     
<div align="center">
<img src="https://github.com/user-attachments/assets/737ba64d-33a8-40e6-b74c-4312bc7dd265">
</div>

   - 1은 10보다 작음. 따라서 왼쪽으로 찾아가고, 1은 5보다 작으므로, 따라서 왼쪽에 저장
   - 6은 10보다 작음. 따라서 왼쪽으로 찾아가고, 6은 5보다 크므로, 따라서 오른쪽에 저장

<div align="center">
<img src="https://github.com/user-attachments/assets/d73f815d-cf1b-48d6-aaad-ad888d3aa6b9">
</div>

   - 11은 10보다 큼. 따라서 오른쪽으로 찾아가고, 11은 15보다 작으므로, 따라서 왼쪽에 저장
   - 16은 10보다 큼. 따라서 오른쪽으로 찾아가고, 16은 15보다 크므로, 따라서 오른쪽에 저장

5. 이진 탐색 트리 - 검색
<div align="center">
<img src="https://github.com/user-attachments/assets/25fc975b-51db-403a-844f-832e19a34979">
</div>

  - 여기에는 총 15개의 데이터가 존재
  - 여기서 숫자 35를 검색한다고 가정
    + 1번 : 루트인 20과 35를 비교 - 35가 더 크므로 오른쪽으로 찾아감
    + 2번 : 40과 35를 비교 -  35가 더 작으므로 왼쪽으로 찾아감
    + 3번 : 30과 35를 비교 -  35가 더 크므로 오른쪽으로 찾아감
    + 4번 : 노드에 있는 값을 비교 - 35와 같으므로 35를 찾음

   - 데이터가 총 15개인데 4번의 계산으로 필요한 결과를 얻을 수 있음
     + 이것은 O(n) 인 리스트의 검색보다는 빠르고, O(1)인 해시의 검색 보다는 느림
     + 리스트의 경우 O(n)이므로 15번의 연산이 필요
     + 해시 검색은 O(1)이므로 1번의 연산이 필요

   - 이진 탐색 트리 계산의 핵심은 한번에 절반을 날린 다는 점
   - 계산을 단순화 하기 위해 16개의 데이터가 있다고 가정
      + 16개의 데이터가 있으며, 루트에서 처음 비교를 통해 절반의 데이터를 찾지 않아도 됨 따라서 16 / 2 = 8
      + 8개의 데이터가 있으며, 비교를 통해 절반의 데이터만 남으므로, 따라서 8 / 2 = 4
      + 4개의 데이터가 있으며, 비교를 통해 절반의 데이터만 남으므로, 따라서 4 / 2 = 2
      + 2개의 데이터가 있으며, 비교를 통해 절반의 데이터만 남으므로, 따라서 2 / 2 = 1
      + 1이 남았으므로 이 값이 맞는지 확인하면 됨

6. 이진 탐색 트리의 빅오 - O(log n)
<div align="center">
<img src="https://github.com/user-attachments/assets/b1889205-a282-4589-9de0-6a5a08da620b">
</div>

  - 16개의 경우 단 4번의 비교 만으로 최종 노드에 도달할 수 있음
    + 2개의 데이터 2로 1번 나누기, log₂(2)=1  
    + 4개의 데이터 2로 2번 나누기, log₂(4)=2
    + 8개의 데이터 2로 3번 나누기, log₂(8)=3
    + 16개의 데이터 2로 4번 나누기, log₂(16)=4
    + 32개의 데이터 2로 5번 나누기, log₂(32)=5
    + 64개의 데이터 2로 6번 나누기, log₂(64)=6
      ...  
    + 1024개의 데이터 2로 10번 나누기, log₂(1024)=10
      
  - 1024개의 데이터를 단 10번의 계산으로 원하는 결과를 찾을 수 있음
  - 데이터의 크기가 늘어나도 늘어난 만큼 한 번의 계산에 절반을 날려버리기 때문에, O(n)과 비교해서 데이터의 크기가 클 수록 효과적인데, 이것을 수학으로 log₂(n) 으로 표현
  - 로그는 쉽게 이야기해서 2로 몇 번 나누어서 1에 도달할 수 있는지 계산하면 됨
  - 빅오 표기법에서 상수는 사용하지 않으므로 상수를 제외하고 단순히 O(log n) 로 표현

7. 이진 탐색 트리와 성능
   - 이진 탐색 트리의 검색, 삽입, 삭제의 평균 성능은 O(log n)
   - 하지만 트리의 균형이 맞지 않으면 최악의 경우 O(n)의 성능이 나옴
   - 만약 데이터를 1, 5, 6, 10, 15 순서로 입력했다고 가정
<div align="center">
<img src="https://github.com/user-attachments/assets/d9e80c0e-3218-4369-86a1-33e6887a246b">
</div>

   - 이렇게 오른쪽으로 치우치게 되면, 결과적으로 15를 검색 했을 때 데이터의 수인 5만큼 검색을 해야함
   - 따라서 이런 최악의 경우 O(n)의 성능

8. 이진 탐색 트리의 개선
   - 트리의 균형이 너무 깨진 경우 동적으로 균형을 다시 맞추는것
<div align="center">
<img src="https://github.com/user-attachments/assets/204481a7-04c0-4d25-ba48-8cd80596def7">
</div>

   - 앞서 중간에 있는 6을 기준으로 다시 정렬
   - AVL 트리, 레드-블랙 트리 같은 균형을 맞추는 다양한 알고리즘이 존재
   - 자바의 TreeSet 은 레드-블랙 트리를 사용해서 균형을 지속해서 유지
   - 따라서 최악의 경우에도 O(logn) 의 성능을 제공

9. 이진 탐색 트리 - 순회
    - 이진 탐색 트리의 핵심은 입력 순서가 아니라, 데이터의 값을 기준으로 정렬해서 보관한다는 점
    - 따라서 정렬된 순서로 데이터를 차례로 조회 가능 (순회 가능)
    - 데이터를 차례로 순회하려면 중위 순회라는 방법을 사
      + 왼쪽 서브트리를 방문한 다음, 현재 노드를 처리하고, 마지막으로 오른쪽 서브트리를 방문
      + 이 방식은 이진 탐색 트리의 특성상, 노드를 오름차순(숫자가 점점 커짐)으로 방문

7. 중위 순회 순서
<div align="center">
<img src="https://github.com/user-attachments/assets/fcfca76f-2c29-44ff-b055-b689329871fc">
</div>

   - 쉽게 이야기해서 자신의 왼쪽의 모든 노드를 처리하고, 자신의 노드를 처리하고, 자신의 오른쪽 모든 노드를 처리하는 방식
   - 10의 기준에서 왼쪽 서브트리를 방문
     + 5의 기준에서 왼쪽 서브트리를 방문 : 1을 출력
     + 5 자신을 출력한다.
     + 5의 기준으로 오른쪽 서브트리를 방문 : 6을 출력

   - 10 자신을 출력
   - 10의 기준에서 오른쪽 서브트리를 방문
     + 15의 기준에서 왼쪽 서브트리를 방문 : 11을 출력
   - 15 자신을 출력
     + 15의 기준으로 오른쪽 서브트리를 방문 : 16을 출력

   - 순서대로 1, 5, 6, 10, 11, 15, 16이 출력된 것을 확인 가능
